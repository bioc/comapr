---
title: "BootstrapAnalysis"
author: "Ruqian"
date: "03/02/2020"
output: html_document
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 8
)
```

```{r setup}
devtools::load_all()

suppressPackageStartupMessages({
  library(readxl)
  library(ggplot2)
  library(dplyr)
  library(reshape2)
  library(chromoMap)
  library(UpSetR)
  library(ggrepel)
  library(comapr)
  library(ggplot2)
  library(reshape2)
  library(dplyr)
})
```


## Load data sheet Mutant

We load the SNP genotyping data from excel spreadsheet, here we are using the sheet "mutant_25-6-19_informative" from All_data_May_to_August_2019.xlsx.

```{r}

mutate_inform1 <- read_excel(path = "../data/All_data_May_to_August_2019.xlsx",
                             sheet = "mutant_25-6-19_informative")
# mutant_25-6-19_informative
mutate_inform1 <- data.frame(mutate_inform1)

mutate_inform1[duplicated(paste0(mutate_inform1$CHR,"_",mutate_inform1$POS)),]
mutate_inform1$CHR_POS <- paste0(mutate_inform1$CHR,"_",mutate_inform1$POS)

rownames(mutate_inform1) <- mutate_inform1$CHR_POS


mt_gt_matrix <- mutate_inform1[,grep("[0-9].*[0-9]$",colnames(mutate_inform1))]

head(mt_gt_matrix)
```

`plotMissingGT` generates dot plots plot of markers by samples indicating which markers are missing from which samples.

```{r}
plotMissingGT(gt_matrix = mt_gt_matrix, plot_wg = FALSE)+theme_classic()+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

### Correct the geneotypes 

Next, we correct the geneotypes which includes 1), change genotype to labels, 2) infer the missing genotypes, 3) change "Home_ref" to "Het".

```{r}
#rownames(gt_matrix)
mt_gt_matrix <- correctGT(gt_matrix = mt_gt_matrix,
                       ref = mutate_inform1$C57BL.6J,
                       alt = mutate_inform1$FVB.NJ..i.)
```

Then we plot the missing genotype again, there are still some SNP markers that have missing values:

```{r}
plotMissingGT(gt_matrix = mt_gt_matrix, plot_wg = FALSE)+theme_classic()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

### Filter genotype matrix 

We need to remove the missing markers to make the entire dataset suitable for statistical testing (i.e for testing difference in genetic lengths in contrasting groups).

We can either remove markers with missing genotype or samples with any missing genotype. 

Let's first check how many markers have missing values/ how many samples have missing values:

```{r}
cts <- countGT(mt_gt_matrix,plot = TRUE, interactive = FALSE)
```

We can also generate interactive plot:

```{r}
ply_cts <- countGT(mt_gt_matrix,plot = TRUE, interactive = TRUE)
ply_cts$ply
```

Filter samples:

```{r}


#p$plot
mt_gt_matrix_filtered <- filterGT(mt_gt_matrix,min_markers = 245)

p <- countGT(mt_gt_matrix_filtered,plot = TRUE, interactive = FALSE)
```

Filter markers

```{r}
#p$plot
## filter NA markers
## The idea here is because we will do K-S test on the kosambi genetic lengths calculated we would like to make sure they are derived on the
## same set of marker intervals


mt_gt_matrix_filtered <- filterGT(mt_gt_matrix_filtered,min_samples = 14)

p <- countGT(mt_gt_matrix_filtered,plot = TRUE, interactive = FALSE)
```


We choose to retain all samples and filter out some markers. We now have 251 markers by 22 samples

Check there is no NA in the genotype matrix anymore:

We still have some NA genotypes in the genotype matrix.

```{r}
sum(apply(mt_gt_matrix_filtered,1,anyNA))
```

### Find duplicated samples 

We next check if any samples are duplicated by checking the pair-wise sample genotype similarity:

```{r}

## Find duplicated samples
dups_samples <- findDupSamples(mt_gt_matrix_filtered)
## 
```

Sample X99 and X98 are duplicated, remove one of them

```{r}
mt_gt_matrix_filtered <- mt_gt_matrix_filtered[,colnames(mt_gt_matrix_filtered) !="X98"]

```

Check there is no duplicated sample anymore:

```{r}
dup_samples <- findDupSamples(mt_gt_matrix_filtered)
dup_samples
```



### Detect crossovers

We find crossovers within each marker intervals across all samples by calling the `detectCO` function. 

For intervals tha have NA values for some samples, they are due to the genotypes for relevant SNP markers are missing.

```{r}
#saveRDS(mt_gt_matrix_filtered, file="../data/")
mt_gt_matrix_filtered_co <- detectCO(gt_matrix = mt_gt_matrix_filtered,
                          chrs = sapply(strsplit(rownames(mt_gt_matrix_filtered),"_"),`[[`,1),
                          chrPos = sapply(strsplit(rownames(mt_gt_matrix_filtered),"_"),`[[`,2),
                          type = "bool")

```

If we set the type of the returned matrix as "counts", this function returns a matrix with cumulative crossover counts.

```{r}
mt_gt_matrix_filtered_co_counts <- detectCO(gt_matrix = mt_gt_matrix_filtered,
                          chrs = sapply(strsplit(rownames(mt_gt_matrix_filtered),"_"),`[[`,1),
                          chrPos = sapply(strsplit(rownames(mt_gt_matrix_filtered),"_"),`[[`,2),
                          type = "counts")


```

The row names of this `gt_matrix_co` indicating the marker interval ID which tells "Chr_Start_End" of the interval. 
"firstM" indicates the interval is the fisrt SNP marker on this chromosome.

Next we prepare the matrix for feeding into `calGeneticMap` function as below:

```{r}
mt_gt_matrix_filtered_co$interval_ID <- rownames(mt_gt_matrix_filtered_co)
mt_gt_matrix_filtered_co_by_marker <- melt(mt_gt_matrix_filtered_co, id = "interval_ID")

colnames(mt_gt_matrix_filtered_co_by_marker) <- c("interval_ID","Sample","Cross_over")

mt_gt_matrix_filtered_co_by_marker$interval_ID <- as.character(mt_gt_matrix_filtered_co_by_marker$interval_ID)

head(mt_gt_matrix_filtered_co_by_marker)
```



### Calculate genetic map

Then we call `calGeneticMap` which generates the point estimates of crossover rate, upper_ci, lower_ci and the mapped kosambi/haldane genetic lengths for each interval.

```{r}
#head(gt_matrix_co_by_marker)

## Problems in getting kosambi confidence interval, NaN produced

mt_gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = mt_gt_matrix_filtered_co_by_marker )

mt_gt_matrix_dist$CHR  <-  sapply(strsplit(mt_gt_matrix_dist$interval_ID,"_"),`[[`,1)

mt_gt_matrix_dist$POS <-   as.numeric(sapply(strsplit(mt_gt_matrix_dist$interval_ID,"_"),`[[`,3))

mt_gt_matrix_dist$CHR  <-  factor(mt_gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
mt_gt_matrix_dist <- mt_gt_matrix_dist[order(mt_gt_matrix_dist$CHR, rank(mt_gt_matrix_dist$POS,na.last = FALSE)), ]

mt_gt_matrix_final <- mt_gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))

#gt_matrix_dst[sort(gt_matrix_dst$CHR,gt_matrix_dst$POS),]

```

total centimorgans by kosambi for mutant_25-6-19_informative

```{r}
k_sum_mt  <- sum(mt_gt_matrix_final$kosambi*100)
k_sum_mt
```


## Load data sheet Wildtype

We load the SNP genotyping data from excel spreadsheet, here we are using the sheet "mutant_25-6-19_informative" from All_data_May_to_August_2019.xlsx.

```{r}

wildtype_inform1 <- read_excel(path = "../data/All_data_May_to_August_2019.xlsx",
                             sheet = "wildtype_2-5-19_informative")
wildtype_inform1 <- data.frame(wildtype_inform1)

wildtype_inform1[duplicated(paste0(wildtype_inform1$CHR,"_",wildtype_inform1$POS)),]
wildtype_inform1$CHR_POS <- paste0(wildtype_inform1$CHR,"_",wildtype_inform1$POS)

rownames(wildtype_inform1) <- wildtype_inform1$CHR_POS


wt_gt_matrix <- wildtype_inform1[,grep("[0-9].*[0-9]$",colnames(wildtype_inform1))]

head(wt_gt_matrix)
```

`plotMissingGT` generates dot plots plot of markers by samples indicating which markers are missing from which samples.

```{r}
plotMissingGT(gt_matrix = wt_gt_matrix, plot_wg = FALSE)+theme_classic()+ 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

### Correct the geneotypes 

Next, we correct the geneotypes which includes 1), change genotype to labels, 2) infer the missing genotypes, 3) change "Home_ref" to "Het".

```{r}
#rownames(gt_matrix)
wt_gt_matrix <- correctGT(gt_matrix = wt_gt_matrix,
                       ref = wildtype_inform1$C57BL.6J,
                       alt = wildtype_inform1$FVB.NJ..i.)
```

Then we plot the missing genotype again, there are still some SNP markers that have missing values:

```{r}
plotMissingGT(gt_matrix = wt_gt_matrix, plot_wg = FALSE)+theme_classic()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

### Filter genotype matrix 

We need to remove the missing markers to make the entire dataset suitable for statistical testing (i.e for testing difference in genetic lengths in contrasting groups).

We can either remove markers with missing genotype or samples with any missing genotype. 

Let's first check how many markers have missing values/ how many samples have missing values:

```{r}
cts <- countGT(wt_gt_matrix,plot = TRUE, interactive = FALSE)
```

We can also generate interactive plot:

```{r}
ply_cts <- countGT(wt_gt_matrix,plot = TRUE, interactive = TRUE)
ply_cts$ply
```

Filter samples:

```{r}


#p$plot
wt_gt_matrix_filtered <- filterGT(wt_gt_matrix,min_markers = 245)

p <- countGT(wt_gt_matrix_filtered,plot = TRUE, interactive = FALSE)
```

Filter markers

```{r}
#p$plot
## filter NA markers
## The idea here is because we will do K-S test on the kosambi genetic lengths calculated we would like to make sure they are derived on the
## same set of marker intervals


wt_gt_matrix_filtered <- filterGT(wt_gt_matrix_filtered,min_samples = 14)

p <- countGT(wt_gt_matrix_filtered,plot = TRUE, interactive = FALSE)
```


We choose to retain all samples and filter out some markers. We now have 251 markers by 22 samples

Check there is no NA in the genotype matrix anymore:

We still have some NA genotypes in the genotype matrix.

```{r}
sum(apply(wt_gt_matrix_filtered,1,anyNA))
```

### Find duplicated samples 

We next check if any samples are duplicated by checking the pair-wise sample genotype similarity:

```{r}

## Find duplicated samples
dups_samples <- findDupSamples(wt_gt_matrix_filtered)
## 
```

No duplicated samples

### Detect crossovers

We find crossovers within each marker intervals across all samples by calling the `detectCO` function. 

For intervals tha have NA values for some samples, they are due to the genotypes for relevant SNP markers are missing.

```{r}
#saveRDS(wt_gt_matrix_filtered, file="../data/")
wt_gt_matrix_filtered_co <- detectCO(gt_matrix = wt_gt_matrix_filtered,
                          chrs = sapply(strsplit(rownames(wt_gt_matrix_filtered),"_"),`[[`,1),
                          chrPos = sapply(strsplit(rownames(wt_gt_matrix_filtered),"_"),`[[`,2),
                          type = "bool")

```

If we set the type of the returned matrix as "counts", this function returns a matrix with cumulative crossover counts.

```{r}
wt_gt_matrix_filtered_co_counts <- detectCO(gt_matrix = wt_gt_matrix_filtered,
                          chrs = sapply(strsplit(rownames(wt_gt_matrix_filtered),"_"),`[[`,1),
                          chrPos = sapply(strsplit(rownames(wt_gt_matrix_filtered),"_"),`[[`,2),
                          type = "counts")


```

The row names of this `gt_matrix_co` indicating the marker interval ID which tells "Chr_Start_End" of the interval. 
"firstM" indicates the interval is the fisrt SNP marker on this chromosome.

Next we prepare the matrix for feeding into `calGeneticMap` function as below:

```{r}
wt_gt_matrix_filtered_co$interval_ID <- rownames(wt_gt_matrix_filtered_co)
wt_gt_matrix_filtered_co_by_marker <- melt(wt_gt_matrix_filtered_co, id = "interval_ID")

colnames(wt_gt_matrix_filtered_co_by_marker) <- c("interval_ID","Sample","Cross_over")

wt_gt_matrix_filtered_co_by_marker$interval_ID <- as.character(wt_gt_matrix_filtered_co_by_marker$interval_ID)

head(wt_gt_matrix_filtered_co_by_marker)
```



### Calculate genetic map

Then we call `calGeneticMap` which generates the point estimates of crossover rate, upper_ci, lower_ci and the mapped kosambi/haldane genetic lengths for each interval.

```{r}
#head(gt_matrix_co_by_marker)

## Problems in getting kosambi confidence interval, NaN produced

wt_gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = wt_gt_matrix_filtered_co_by_marker )

wt_gt_matrix_dist$CHR  <-  sapply(strsplit(wt_gt_matrix_dist$interval_ID,"_"),`[[`,1)

wt_gt_matrix_dist$POS <-   as.numeric(sapply(strsplit(wt_gt_matrix_dist$interval_ID,"_"),`[[`,3))

wt_gt_matrix_dist$CHR  <-  factor(wt_gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
wt_gt_matrix_dist <- wt_gt_matrix_dist[order(wt_gt_matrix_dist$CHR, rank(wt_gt_matrix_dist$POS,na.last = FALSE)), ]

wt_gt_matrix_final <- wt_gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))

#gt_matrix_dst[sort(gt_matrix_dst$CHR,gt_matrix_dst$POS),]

```

total centimorgans by kosambi for mutant_25-6-19_informative

```{r}
k_sum_wt  <- sum(wt_gt_matrix_final$kosambi*100)
k_sum_wt
```
### Boostrapping

```{r boostrapping_prepare}
head(wt_gt_matrix_filtered_co)
head(mt_gt_matrix_filtered_co)
observed <- k_sum_mt - k_sum_wt
observed
```

```{r}
dim(wt_gt_matrix_filtered_co)
dim(mt_gt_matrix_filtered_co)
```

### Pool samples and generate random combination

```{r}
common_markers <- intersect(rownames(mt_gt_matrix_filtered_co),
                            rownames(wt_gt_matrix_filtered_co))
length(common_markers)
mt_gt_matrix_filtered_co_clean <- mt_gt_matrix_filtered_co[common_markers,]
wt_gt_matrix_filtered_co_clean <- wt_gt_matrix_filtered_co[common_markers,]
```

observed diff after cleaning

```{r}
## Problems in getting kosambi confidence interval, NaN produced
wt_clean_by_marker <- melt(wt_gt_matrix_filtered_co_clean, id = "interval_ID")

colnames(wt_clean_by_marker) <- c("interval_ID","Sample","Cross_over")

wt_clean_by_marker$interval_ID <- as.character(wt_clean_by_marker$interval_ID)

head(wt_clean_by_marker)

wt_gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = wt_clean_by_marker )

wt_gt_matrix_dist$CHR  <-  sapply(strsplit(wt_gt_matrix_dist$interval_ID,"_"),`[[`,1)

wt_gt_matrix_dist$POS <-   as.numeric(sapply(strsplit(wt_gt_matrix_dist$interval_ID,"_"),`[[`,3))

wt_gt_matrix_dist$CHR  <-  factor(wt_gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
wt_gt_matrix_dist <- wt_gt_matrix_dist[order(wt_gt_matrix_dist$CHR, 
                                             rank(wt_gt_matrix_dist$POS,na.last = FALSE)), ]

wt_gt_matrix_final <- wt_gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))
k_sum_clean_wt <- sum(wt_gt_matrix_final$kosambi*100)


mt_clean_by_marker <- melt(mt_gt_matrix_filtered_co_clean, id = "interval_ID")

colnames(mt_clean_by_marker) <- c("interval_ID","Sample","Cross_over")

mt_clean_by_marker$interval_ID <- as.character(mt_clean_by_marker$interval_ID)

head(mt_clean_by_marker)

mt_gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = mt_clean_by_marker )

mt_gt_matrix_dist$CHR  <-  sapply(strsplit(mt_gt_matrix_dist$interval_ID,"_"),`[[`,1)

mt_gt_matrix_dist$POS <-   as.numeric(sapply(strsplit(mt_gt_matrix_dist$interval_ID,"_"),`[[`,3))

mt_gt_matrix_dist$CHR  <-  factor(mt_gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
mt_gt_matrix_dist <- mt_gt_matrix_dist[order(mt_gt_matrix_dist$CHR, 
                                             rank(mt_gt_matrix_dist$POS,na.last = FALSE)), ]

mt_gt_matrix_final <- mt_gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))
k_sum_clean_mt <- sum(mt_gt_matrix_final$kosambi*100)

k_sum_clean_mt - k_sum_clean_wt

```
Pool samples and randomnize

```{r}
pooled <- cbind(wt_gt_matrix_filtered_co_clean[,1:(ncol(wt_gt_matrix_filtered_co_clean)-1)], 
                mt_gt_matrix_filtered_co_clean[,1:(ncol(mt_gt_matrix_filtered_co_clean)-1)])

dim(wt_gt_matrix_filtered_co_clean)
dim(mt_gt_matrix_filtered_co_clean)

dim(pooled)

getDiff <- function(mt_m, wt_m)
{
  
  wt_clean_by_marker <- melt(wt_m, id = "interval_ID")

colnames(wt_clean_by_marker) <- c("interval_ID","Sample","Cross_over")

wt_clean_by_marker$interval_ID <- as.character(wt_clean_by_marker$interval_ID)

wt_gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = wt_clean_by_marker )

wt_gt_matrix_dist$CHR  <-  sapply(strsplit(wt_gt_matrix_dist$interval_ID,"_"),`[[`,1)

wt_gt_matrix_dist$POS <-   as.numeric(sapply(strsplit(wt_gt_matrix_dist$interval_ID,"_"),`[[`,3))

wt_gt_matrix_dist$CHR  <-  factor(wt_gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
wt_gt_matrix_dist <- wt_gt_matrix_dist[order(wt_gt_matrix_dist$CHR, 
                                             rank(wt_gt_matrix_dist$POS,na.last = FALSE)), ]

wt_gt_matrix_final <- wt_gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))
k_sum_clean_wt <- sum(wt_gt_matrix_final$kosambi*100)

mt_clean_by_marker <- melt(mt_m, id = "interval_ID")

colnames(mt_clean_by_marker) <- c("interval_ID","Sample","Cross_over")

mt_clean_by_marker$interval_ID <- as.character(mt_clean_by_marker$interval_ID)

head(mt_clean_by_marker)

mt_gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = mt_clean_by_marker )

mt_gt_matrix_dist$CHR  <-  sapply(strsplit(mt_gt_matrix_dist$interval_ID,"_"),`[[`,1)

mt_gt_matrix_dist$POS <-   as.numeric(sapply(strsplit(mt_gt_matrix_dist$interval_ID,"_"),`[[`,3))

mt_gt_matrix_dist$CHR  <-  factor(mt_gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
mt_gt_matrix_dist <- mt_gt_matrix_dist[order(mt_gt_matrix_dist$CHR, 
                                             rank(mt_gt_matrix_dist$POS,na.last = FALSE)), ]

mt_gt_matrix_final <- mt_gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))
k_sum_clean_mt <- sum(mt_gt_matrix_final$kosambi*100)

return(k_sum_clean_mt - k_sum_clean_wt)

}

getDiff(mt_gt_matrix_filtered_co_clean,wt_gt_matrix_filtered_co_clean)
```
#### Permutation test

```{r, message=FALSE,warning=FALSE}

#combn(x = ncol(pooled),m = (ncol(wt_gt_matrix_filtered_co_clean)-1))
c_m <- sample(1:39, 17)

B = 1000

permut_samples <- function(B = 100,pooled_matrix,n_wt){
  permute_results <- sapply(1:B, function(x){
    wt_index <- sample(1:dim(pooled_matrix)[2],n_wt)
    mt_index <- setdiff(1:dim(pooled_matrix)[2],wt_index)
    #print(wt_index)
    #print(mt_index)
    wt_matrix <- pooled_matrix[wt_index]
    mt_matrix <- pooled_matrix[mt_index]
    wt_matrix$interval_ID <- rownames(wt_matrix)
    mt_matrix$interval_ID <- rownames(mt_matrix)
    
    getDiff(mt_matrix,wt_matrix)
  })
  return(permute_results)
}
p_results <- permut_samples(1000, pooled, 
               n_wt = (ncol(wt_gt_matrix_filtered_co_clean)-1) )
getPval <- function(observe, permut_results){
  return(sum (permut_results > observe) / length(permut_results))
}

getPval(observe = observed, p_results)

```

#### Boostrap and CI

```{r,message=FALSE,warning=FALSE}
boostrap_samples <- function(B = 100,gt_clean){
  
  permute_results <- sapply(1:B, function(x){
  sample_index <- sample(1:ncol(gt_clean),replace = TRUE)
  gt_clean_r <- gt_clean[,sample_index]
  gt_clean_r$interval_ID <- rownames(gt_clean_r)
  gt_clean_by_marker <- melt(gt_clean_r,id = "interval_ID")
  colnames(gt_clean_by_marker) <- c("interval_ID","Sample","Cross_over")
  gt_clean_by_marker$interval_ID <- as.character(gt_clean_by_marker$interval_ID)
  gt_matrix_dist <- calGeneticMap(gt_matrix_co_by_marker = gt_clean_by_marker )
  gt_matrix_dist$CHR <- sapply(strsplit(gt_matrix_dist$interval_ID,"_"),`[[`,1)
  gt_matrix_dist$POS <- as.numeric(sapply(strsplit(gt_matrix_dist$interval_ID,"_"),
                                          `[[`,3))
  gt_matrix_dist$CHR <- factor(gt_matrix_dist$CHR,levels = c(seq(1:19),"X"))

## important to order the markers by chr then by position
  gt_matrix_dist <- gt_matrix_dist[order(gt_matrix_dist$CHR, 
                                             rank(gt_matrix_dist$POS,na.last = FALSE)), ]

  gt_matrix_final <- gt_matrix_dist %>% group_by(CHR) %>% mutate(cum_haldane = cumsum(haldane),
                                                              cum_kosambi = cumsum(kosambi))
k_sum <- sum(gt_matrix_final$kosambi*100)
return(k_sum)
  })
  return(permute_results)
}

boostrap_results_wt <- boostrap_samples(1000,wt_gt_matrix_filtered_co_clean[,1:(ncol(wt_gt_matrix_filtered_co_clean)-1)])

quantile(boostrap_results_wt,probs = c(0.025,0.975))

boostrap_results_mt <- boostrap_samples(1000,mt_gt_matrix_filtered_co_clean[,1:(ncol(mt_gt_matrix_filtered_co_clean)-1)])

quantile(boostrap_results_mt,probs = c(0.025,0.975))

```


### Plots

```{r}
ggplot(data = gt_matrix_final)+geom_point(mapping = aes(x = POS, y = cum_haldane ),color = "blue")+
  facet_wrap(.~CHR)+geom_point(mapping = aes(x = POS, y = cum_kosambi ),color = "red")+ggtitle("cum_haldane (blue),cum_kosambi (red)")+
  theme(axis.text.x = element_blank())+ylab(label = "cumulative genetic length")
#
#tt <- gt_matrix_final %>% group_by(CHR) %>% mutate(sum_chr = sum(kosambi))



# ggplot(data = gt_matrix_final)+geom_point(mapping = aes(x = CHR,y = cum_kosambi*100),stat = "identity")+
#   geom_label_repel(mapping = aes(x = CHR,y = cum_kosambi*100,label = interval_ID))+
#   geom_bar(data = tt[!duplicated(tt$CHR),],mapping = aes(y = CHR,x = sum_chr*100),
#            width = .5,stat = "identity",alpha  = 0.2)
```
```{r,fig.width=10}
plotdf <- gt_matrix_final
plotdf$interval_ID <- factor(plotdf$interval_ID, levels = plotdf$interval_ID[order(plotdf$pointEst)] )
ggplot(data = plotdf)+geom_point(mapping = aes(x = interval_ID, y = pointEst))+geom_errorbar(
  mapping = aes(ymax = upper_ci, ymin = lower_ci,x = interval_ID,
                colour = CHR)
)+theme_classic()+theme(axis.text.x = element_blank())+ylab("crossover rate point estimate and confidence interval")+facet_wrap(.~CHR,
                                                                                                                                scales = "free")
```

Total genetic length

```{r,fig.width=10}
plotdf <- gt_matrix_final

ggplot(data = plotdf)+geom_point(mapping = aes(x = interval_ID, y = cum_kosambi))+theme_classic()+theme(axis.text.x = element_blank())+
  ylab("kosambi genetic lengths per interval")+facet_wrap(.~CHR)
    

plot_df <- gt_matrix_final
########
head(plot_df)
plot_df <- plot_df[order(plot_df$CHR, xtfrm(plot_df$POS)), ]
head(plot_df)
ggplot(data = plot_df)+geom_point(mapping = aes(x = POS, y= cum_kosambi))+facet_wrap(.~CHR)+
  ggtitle(label = paste0("total genetic length Mutant June: \n",round(sum(plot_df$kosambi*100),2)))+
  ylab("cumulative kosambi genetic lengths per chromosome")



df.tmp <- plot_df %>%

  # Compute chromosome size
  group_by(CHR) %>%
  summarise(chr_len=max(POS)) %>%

  # Calculate cumulative position of each chromosome
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  select(-chr_len) %>%

  # Add this info to the initial dataset
  left_join(plot_df, ., by=c("CHR"="CHR")) %>%

  # Add a cumulative position of each SNP
  arrange(CHR, POS) %>%
  mutate( BPcum=POS+tot)
# get chromosome center positions for x-axis
axisdf <- df.tmp %>% group_by(CHR) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )
df.tmp$wg_cum_kosambi <- 0

df.tmp$wg_cum_kosambi <- cumsum(df.tmp$kosambi)

ggplot(data = df.tmp)+geom_point(mapping = aes(x = BPcum, y= wg_cum_kosambi))+
  ggtitle(label = paste0("total genetic length Mutant June: \n",
                         round(sum(plot_df$kosambi)*100,2)))+
  theme(axis.text.x  = element_text(angle = 90, hjust = 1))+scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center)+
  ylab("Whole Genome cumulative kosambi genetic length")+theme_classic()

```



